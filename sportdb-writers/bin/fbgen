#!/usr/bin/env ruby

## tip: to test run:
##   ruby -I ./lib bin/fbgen


require 'sportdb/writers'

require 'optparse'



args=ARGV


opts = {
  source_path: [],
  push:     false,
  dry:      false,  ## dry run (no write)
  debug:    true,
}



parser = OptionParser.new do |parser|
  parser.banner = "Usage: #{$PROGRAM_NAME} [options] [args]"

    parser.on( "-p", "--push",
               "fast forward sync and commit & push changes to git repo - default is (#{opts[:push]})" ) do |push|
      opts[:push] = push
    end
    parser.on( "--dry",
                "dry run; do NOT write - default is (#{opts[:dry]})" ) do |dry|
      opts[:dry] = dry
    end
    parser.on( "-q", "--quiet",
               "less debug output/messages - default is (#{!opts[:debug]})" ) do |debug|
      opts[:debug] = !debug
    end
end
parser.parse!( args )



if opts[:source_path].empty? &&
  File.exist?( '/sports/cache.api.fbdat')  &&
  File.exist?( '/sports/cache.wfb' )
 opts[:source_path] << '/sports/cache.api.fbdat'
 opts[:source_path] << '/sports/cache.wfb'
end


puts "OPTS:"
p opts
puts "ARGV:"
p args


### split args in datasets with leagues and seasons
datasets = []


args.each do |arg|
   if arg =~ %r{^[0-9/-]+$}   ##  season
       if datasets.empty?
         puts "!! ERROR - league required before season arg; sorry"
         exit 1
       end

       season = Season.parse( arg )  ## check season
       datasets[-1][1] << season
   else ## assume league key
       key = arg.downcase
       league_info = Writer::LEAGUES[ key ]

       if league_info.nil?
         puts "!! ERROR - no league found for >#{key}<; sorry"
         exit 1
       end

       datasets << [key, []]
   end
end

pp datasets



def find_file( filename, path: )
   path.each do |src_dir|
      path = "#{src_dir}/#{filename}"
      return path   if File.exist?( path )
   end

   ##  fix - raise file not found error!!!
   nil  ## not found - raise filenot found error - why? why not?
end


source_path = opts[:source_path]
source_path = ['.']    if source_path.empty?  ## use ./ as default


root_dir =  if opts[:push]
               SportDb::GitHubSync.root   # e.g. "/sports/openfootball"
            else
               './o'
            end


puts "  (output) root_dir: >#{root_dir}<"

sync  = if opts[:push]
             SportDb::GitHubSync.new( datasets )
        else
              nil
        end
puts "  sync:"
pp sync

sync.git_fast_forward_if_clean      if sync



datasets.each do |league_key, seasons|
    seasons = [ Season('2024/25') ]   if seasons.empty?

    puts "==> gen #{league_key} - #{seasons.size} seasons(s)..."

    league_info = Writer::LEAGUES[ league_key ]
    pp league_info

    seasons.each do |season|
      ### get matches

      filename = "#{season.to_path}/#{league_key}.csv"
      path = find_file( filename, path: source_path )

      puts "  ---> reading matches in #{path} ..."
      matches = SportDb::CsvMatchParser.read( path )
      puts "     #{matches.size} matches"

      ## build
      txt = SportDb::TxtMatchWriter.build( matches )
      puts txt   if opts[:debug]

      league_name  = league_info[ :name ]      # e.g. Brasileiro SÃ©rie A
      basename     = league_info[ :basename]   #.e.g  1-seriea

      league_name =  league_name.call( season )   if league_name.is_a?( Proc )  ## is proc/func - name depends on season
      basename    =  basename.call( season )      if basename.is_a?( Proc )  ## is proc/func - name depends on season

      buf = String.new
      buf << "= #{league_name} #{season}\n\n"
      buf << txt

      repo_path  = SportDb::GitHubSync::REPOS[ league_key ]

      outpath = "#{root_dir}/#{repo_path}/#{season.to_path}/#{basename}.txt"
      if opts[:dry]
        puts "   (dry) writing to >#{outpath}<..."
      else
        write_text( outpath, buf )
      end
    end
end


sync.git_push_if_changes   if sync


puts "bye"