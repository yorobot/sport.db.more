#!/usr/bin/env ruby

## tip: to test run:
##   ruby -I ./lib bin/wfb

require 'worldfootball'


Webcache.root =  if File.exist?( '/sports/cache' )
                     puts "  setting web cache to >/sports/cache<"
                     '/sports/cache'
                 else
                     './cache'
                 end

## convert (default) output directory
Worldfootball.config.convert.out_dir = if File.exist?( '/sports/cache.wfb')
                                           puts "  setting convert out_dir to >/sports/cache.wfb<"
                                           '/sports/cache.wfb'
                                        else
                                           '.' ## use working dir
                                        end

require 'optparse'


module Worldfootball
def self.main( args=ARGV )

opts = {
    cached:  false,
    convert: true,
    file:    nil,
    dry:     false,
 }


parser = OptionParser.new do |parser|
  parser.banner = "Usage: #{$PROGRAM_NAME} [options]"

##
## check if git has a offline option?? (use same)
##             check for other tools - why? why not?

## todo - add a single letter option for offline/cached

  parser.on( "--cache", "--cached", "--offline",
               "use cached data in #{Webcache.root}" ) do |cached|
    opts[:cached] = cached
  end

  parser.on( "--[no-]convert",
               "turn on/off conversion to .csv in #{Worldfootball.config.convert.out_dir} - default is (#{opts[:convert]})" ) do |convert|
    opts[:convert] = convert
  end

  parser.on( "--dry",
                "dry run; do NOT write - default is (#{opts[:dry]})" ) do |dry|
    opts[:dry] = dry
  end

  parser.on( "-f FILE", "--file FILE",
                "read leagues (and seasons) via .csv file") do |file|
    opts[:file] = file
  end
end




parser.parse!( args )

puts "OPTS:"
p opts
puts "ARGV:"
p args


### check special (built-in) commands first
if ['cache'].include?( args[0] )
    Worldfootball.list_pages
    exit 0
end


if ['league', 'leagues', 'ls'].include?( args[0] )
    keys = LEAGUES.keys

    pp keys
    puts "   #{keys.size} league(s)"

    # puts
    # puts " pages:"
    # pp Worldfootball::PAGES

    exit 0
end


####
#  assume leagues

datasets = if opts[:file]
              read_datasets( opts[:file] )
           else
              parse_datasets_args( args )
           end


datasets.each do |league_key, seasons|

  league =  find_league!( league_key )  ## league info lookup

  if opts[:dry]
     ## output more page meta info
     puts "league meta:"
     pp league
  end

  ## note - default to latest season of league
  ##              might be 2024/25 or 2024 or
  #                 for world cup 2022 or such
  seasons = [Season(league.seasons.keys[0])]    if seasons.empty?


  seasons.each do |season|
      pages = league.pages!( season: season )
      puts
      pp [league.key, season.key]
      pp pages
      puts "   #{pages.size} page(s)"


      next  if opts[:dry]    ## stop here if dry run

      if opts[:cached]
          # do nothing
      else  ## download to cache
        pages.each_with_index do |(slug,_),i|
          puts "==> #{i+1}/#{pages.size} - #{league_key} @ #{slug}..."
          page = Metal.download_schedule( slug )
        end
      end

      pages.each_with_index do |(slug,_),i|
        puts "==> #{i+1}/#{pages.size} - #{league_key} @ #{slug}..."
        page = Page::Schedule.from_cache( slug )
        matches = page.matches

        puts "   #{matches.size} match(es)"
      end

      if opts[:convert]
        ## write out (export to) comma-separated values (.csv) datafile
        convert( league: league_key,
                 season: season )
      end
end # each seasons
end # each league


end   # def self.main
end   # module Worldfootball


Worldfootball.main( ARGV )


puts "bye"
